== Java Modulsystem

Hier sind die Übungsbeschreibungen zu den Modulübungen.

Die Beschreibungen zu den anderen Übungen sind in den weiligen Unterordnern.

=== Automatic Modules - Teil 1

==== Hinweis:
Im Verlauf der nachfolgenden Übungen wird Schritt für Schritt eine modularisierte Beispielanwendung entwickelt. In den Beschreibungen werden verschiedene Packages genannt, welche mit „jupdate“ beginnen. DEr Teil „jupdate“ darf gerne durch andere Basis-Package-Namen ersetzen (z.B. „jupdate.main“ zu „com.example.main“). Damit die Übungen im späteren Verlauf korrekt funktionieren, müssen die Packages aber anhand ihres Suffix klar unterscheidbar sein.
Die einzelnen Zwischenschritte können für späteres Selbststudium gesichert werden.

==== Aufgabenstellung:
. Erstellt in Eurer IDE ein neues Java 9 Projekt
. In Eclipse nennen wir dieses Projekt „main“
. In IntelliJ IDEA erstellen wir ein Modul „main“
. Wir erstellen eine Klasse „StringUtil“ im package „jupdate.util“, welche eine statische Methode „flip“ zum Umkehren von Strings anbietet
. Wir erstellen Sie eine neue Klasse „Main“ im Package „jupdate.main“ mit einer „main“-Methode
. Wir rufen in der „main“-Methode die Methode „flip“ in StringUtil auf und geben sie mit Hilfe von dieser auf der Konsole aus


.Klasse StringUtil
[source,java]
----
package jupdate.util;

public final class StringUtil {

	private StringUtil() {
	}

	public static String flip(String s) {
		final StringBuffer flippedString = new StringBuffer();

		for (int i = (s.length() - 1); i >= 0; i--) {
			flippedString.append(s.charAt(i));
		}

		return flippedString.toString();
	}
}
----

.Klasse StringUtil
[source,java]
----
package jupdate.main;

import jupdate.util.StringUtil;

public class Main {

	public static void main(String[] args) {
		System.out.println(StringUtil.flip("!dlroW olleH"));
	}
}
----

=== Automatic Modules - Teil 2

==== Aufgabenstellung:
. Kompiliere die Quelltexte zu *.class Dateien. Nutzen Sie hierfür entweder Ihre IDE oder die Kommandozeile
. Erzeuge aus Ihren *.class Dateien eine *.jar Datei
. Starte die Anwendung und lade die *.jar Datei über den Classpath
. Ermittle mit Hilfe des Kommandos „jar“ den generierten Namen der *.jar Datei
. Starte die Anwendung und lade die *.jar Datei über den Module Path

.Shell
[source,shell]
----
mkdir out
mkdir lib
javac -d out src/jupdate/main/Main.java src/jupdate/util/StringUtil.java
jar --create --file lib/main.jar -C out .
java -cp lib/main.jar jupdate.main.Main
jar -d --file lib/main.jar
java -p lib/main.jar -m main/jupdate.main.Main
----


==== Ergebnis:
Einfache *.jar-Dateien können ohne Erweiterungen für das Modulsystem auch als Module eingesetzt werden. Dies ermöglicht eine einfache Nutzung von Anwendungsbestandteilen sowohl in einer modularisierten, als auch in einer nicht modularisierten Umgebung.

=== Automatic Modules - Teil 3

==== Aufgabenstellung:
. Erstelle im Projekt eine Datei „MANIFEST.txt“, in welcher das Attribut „Automatic-Module-Name” auf den Werte “jupdate.main” gesetzt ist
. Erzeuge wie zuvor eine *.jar Datei, wobei allerdings der Parameter “-m MANIFEST.txt” an das “jar” Kommando mitgegeben wird

.Shell
[source,shell]
----
jar --create --file lib/main.jar -m MANIFEST.txt -C out .
----

. Prüfe, dass der in der MANIFEST.txt eingestellte Modulname verwendet wird
. Starte die *.jar Datei und verwende den definierten Modulnamen „jupdate.main“

==== Ergebnis:
Durch die Spezifikation des Modulnamens in der MANIFEST.MF einer *.jar Datei können wir erreichen, dass ein Automatic Module einen definierten Namen erhält, welcher nicht vom Namen der Datei abgeleitet wird.

=== Moduldeskriptor

==== Aufgabenstellung:
. Lege im Quellverzeichnis eine Datei „module-info.java“ an und deklariere dort ein Modul namens „jupdate.main“.

.Moduldeskriptor module-info.java
[source,java]
----
module jupdate.main {
}
----

. Kompiliere die Quelldateien inklusive „module-info.java“ und erstelle daraus eine *.jar Datei.
. Starte die Anwendung mit der *.jar Datei auf dem Module Path.
. Vergewissere Dich, dass der Modulname unabhängig vom Dateinamen wie im Moduldeskriptor deklariert erkannt wird.

==== Ergebnis:
Mit Hilfe des Moduldeskriptors „module-info.java“ kann ein Modulname deklariert werden, welcher unabhängig vom Namensschema der *.jar Dateien ein stabiles Verhalten zur Laufzeit garantiert.


=== Abhängigkeiten zu System-Modulen

==== Aufgabenstellung:
. Versuche in der „main“ Methode auf die Java Logging API (Package java.util.logging) zuzugreifen
. Deklariere im Modul „jupdate.main“ eine Abhängigkeit auf das System-Modul „java.logging“

.Moduldeskriptor module-info.java
[source,java]
----
module jupdate.main {
    requires java.logging;
}
----

. Nutze die Java Logging API für die Ausgabe in der Anwendung (statt System.out.println)
. Kompiliere und starte die Anwendung und vergewissere Dich, dass die Ausgabe über die Java Logging API funktioniert

==== Ergebnis:
Ohne Anpassung des Moduldeskriptors „module.info.java“ verwehrt Die IDE sowie der Java Compiler den Zugriff auf Packages, welche sich nicht im implizit referenzierten Modul „java.base“ befinden. Nach Deklaration der notwendigen Abhängigkeit, gelingt der Zugriff, wie wir es von nicht-modularen Anwendungen gewohnt sind.


=== Versionierung von Modulen

==== Aufgabenstellung:
. Werfe testweise eine RuntimeException in der „main“ Methode
. Erstelle die *.jar Datei des Moduls neu und spezifiziere hierbei eine Version für das Modul
. Inspiziere das erzeugte Modul und stellen sicher, dass die vergebene Version wieder auftaucht
. Starte die Anwendung und betrachte den StackTrace

==== Ergebnis:
Wird eine Version bei der Erstellung einer *.jar Datei spezifiziert, so findet sich dieses Metadatum in verschiedenen Ausgaben wieder und kann zum Beispiel zur Fehlersuche verwendet werden.

=== Modulare Anwendung

==== Aufgabenstellung:
. Erweitere die Projektstruktur für ein neues Modul
.. In Eclipse: lege ein neues Java-Projekt „util“ an
.. In IntelliJ IDEA: Erstelle ein neues Modul namens „util“ im Projekt und richte ein Quellverzeichnis „src“ ein
. Erstelle die Datei „module-info.java“ im neuen Quellverzeichnis und deklarieren dort das Modul „jupdate.util“

.module-info.java in main
[source,java]
----
module jupdate.main {
    requires java.logging;
    requires jupdate.util;
}
----

. Lege außerdem das Package „jupdate.util“ an und verschiebe die Klasse „StringUtil“ dorthin
. Exportiere das Package „jupdate.util“ im neuen Modul und definiere eine Abhängigkeit vom bestehenden Modul „jupdate.main“ auf „jupdate.util“

.Moduldeskriptor module-info.java
[source,java]
----
module jupdate.util {
	exports jupdate.util;
}
----

. Zur Korrektur von Fehlern konfigurieren Sie Ihre IDE:
.. In Eclipse: Lege im Java Build Path eine Projekt-Abhängigkeit vom Projekt „main“ auf das Projekt „util“ für den Module Path an
.. In IntelliJ IDEA: Lege in den Moduleinstellungen des Moduls „main“ eine Abhängigkeit auf das Modul „util“ an
. Starte die Anwendung

Ergebnis:
Im Verlauf der Übung teilen wir unser Modul auf und extrahieren die Klasse StringUtil in ein eigenes Modul. Leider müssen die Abhängigkeiten zusätzlich zur Deklaration im Moduldeskriptor redundant in der IDE konfiguriert werden, um einen lauffähigen Zustand zu erhalten.
